# Canards Processor Board Firmware
Firmware for the 2024-2025 processor board, performing state estimation and control for the canards system. Project documentation can be found in the team Google Drive.

## Project Structure
- `src/drivers/`: custom peripheral driver modules
- `src/application/`: high-level application logic modules
- `src/third_party/`: third-party libraries
- `src/common/`: shared resources specific to this project
- `tests/`: everything for [testing](#Unit-Testing)
- Everything else is autogenerated by STM32CubeIDE with few modifications

## Developer Setup
This project is not dependent on STM32CubeIDE.
Code editing, unit testing, and building should be done in the devcontainer.
Only running/debugging on target should be done in STM32CubeIDE.

#### 1. Clone repo
- Clone repo and initialize submodules: ```
   git clone --recurse-submodules https://github.com/waterloo-rocketry/cansw_processor_canards ```

#### 2. Open project in devcontainer
The devcontainer contains the necessary environment setup for editing, unit testing, and building. Most software development work should occur here.
- Open the project using vscode devcontainers.
  - [Install devcontainers](https://code.visualstudio.com/docs/devcontainers/tutorial)
  - In a new vscode window, use `Ctrl+Shift+P`, search `Dev Containers: Open Folder In Container...`, then select this project folder
    - The first time opening the project will take several minutes to build the devcontainer. Subsequent times will be instant.

#### 3. Build and test project in devcontainer
Use `/scripts/run.sh` from a terminal inside the devcontainer to build the project and/or run unit tests.
Some example script usages:

Show how to use the script:
  ```bash
  ./scripts/run.sh help
  ```
Build the Debug configuration (for flashing to actual board):
  ```bash
  ./scripts/run.sh build Debug
  ```
Build and run unit tests:
  ```bash
  ./scripts/run.sh test
  ```

#### 4. Run/debug in STM32CubeIDE
STM32CubeIDE is preferred for flashing/debugging on hardware. NOTE: STM32CubeIDE is not able to build this project. STM32CubeIDE is only used to flash the build from the previous step.
- Import the project into STM32CubeIDE (version 1.16.1 recommended): `File->Import...->Existing Projects into Workspace`
- Build the project (previous step)
- Use an ST-Link programmer to connect to processor board.
- Use STM32CubeIDE run/debug as usual. Launch configurations are persisted in the `.launch` files in this repo.
  - NOTE: since the project can't be built in STM32CubeIDE, auto-building before launch is turned off. You must manually build the project before launching if there are any changes.

#### *ALTERNATIVE 4. Run/debug via Vscode STM32 extension*
*Instead of using STM32CubeIDE, run/debug in vscode is possible using the STM32 vscode extension ([setup info here](https://community.st.com/t5/stm32-mcus/how-to-use-vs-code-with-stm32-microcontrollers/ta-p/742589) ). This was omitted from the devcontainer because 1. CubeIDE debugging features are stronger, and 2. usb passthrough into devcontainers is non-trivial.*

## Testing
The project uses GoogleTest and Fake Function Framework (fff) for unit testing. All testing-related files are in `tests/`.
- Tests are built from `tests/CMakeLists.txt` which is separate from the project's main build config. Building and running tests is done from `scripts/run.sh` described above.
- Test source code should be written in `tests/unit/`.
- Mocks should be made with fff in `tests/mocks/`

### Add a test
- Add new tests in `tests/unit/`. See `test_dummy.cpp` for  the suggested test structure.
- All tests in the folder are detected automatically by the CMakeLists.

### Add a mock
We do not include the STM32 HAL library nor FreeRTOS when compiling the project for unit tests.
So if a source file uses a HAL or FreeRTOS file, those files and their functions must be mocked using fff.

Example:
- `src/drivers/gpio/gpio.c` uses FreeRTOS semaphores via `#include "semphr.h`.
  - In the actual firmware, the real `semphr.h` is included when compiling. But for unit tests, the real `semphr.h` is not included when compiling. So, the unit tests fail to compile (it can't find a `semphr.h` file).
    - To correct this we add a "fake" `semphr.h` in `tests/mocks/semphr.h`. All files in this folder are included when compiling unit test, so the tests now compile.
  - The gpio code uses functions from the real `semphr.h` like `xSemaphoreTake()`. These don't exist in our fake `semphr.h` yet.
    - To correct this we need to create a mock `xSemaphoreTake()` function using fff.
      [fff's Readme](https://github.com/meekrosoft/fff?tab=readme-ov-file#hello-fake-world) describes how to create fake functions. Here's the mock for `xSemaphoreTake()`:
      ```
      // The func to mock: BaseType_t xSemaphoreTake(SemaphoreHandle_t arg0, TickType_t arg1)
      
      DECLARE_FAKE_VALUE_FUNC(BaseType_t, xSemaphoreTake, SemaphoreHandle_t, TickType_t);
      ```
      First we put the *declaration* (DECLARE_FAKE...) in `mocks/semphr.h`. Then, put the actual *definition* (DEFINE_FAKE...) in the corresponding `mocks/semphr.c`.
- Now in the gpio tests, we can access the mocked semaphore functions via fff to test that the gpio code uses semaphores correctly.

### Run tests
Use `./scripts/run.sh` as described above.


## Code Standards
- This project follows the [team-wide embedded coding standard](https://docs.waterloorocketry.com/general/standards/embedded-coding-standard.html).
- Use clang-format for automatic code formatting. The script must be run from the project root directory:
  ```bash
  ./scripts/format.sh
  ```

- Rocketlib is included at `src/third_party/rocketlib`.
- Developers should be aware of the BARR Standard and make an effort to follow it.
